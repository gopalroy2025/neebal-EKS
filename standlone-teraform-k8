Kubernetes:

Kubernetes (K8S) is an open-source workload scheduler with focus on containerized applications.

There are at least 2 steps involved in scheduling your first container on a Kubernetes cluster. You need the Kubernetes cluster with all its components running somewhere and then schedule the Kubernetes resources, like Pods, Replication Controllers, Services etc.

This guide focuses mainly on the latter part and expects you to have a properly configured & running Kubernetes cluster.

The guide also expects you to run the cluster on a cloud provider where Kubernetes can automatically provision a load balancer.

Why Terraform?

While you could use kubectl or similar CLI-based tools mapped to API calls to manage all Kubernetes resources described in YAML files, orchestration with Terraform presents a few benefits.

Use the same configuration language to provision the Kubernetes infrastructure and to deploy applications into it.
drift detection - terraform plan will always present you the difference between reality at a given time and config you intend to apply.
full lifecycle management - Terraform doesn't just initially create resources, but offers a single command for creation, update, and deletion of tracked resources without needing to inspect the API to identify those resources.
synchronous feedback - While asynchronous behaviour is often useful, sometimes it's counter-productive as the job of identifying operation result (failures or details of created resource) is left to the user. e.g. you don't have IP/hostname of load balancer until it has finished provisioning, hence you can't create any DNS record pointing to it.
graph of relationships - Terraform understands relationships between resources which may help in scheduling - e.g. if a Persistent Volume Claim claims space from a particular Persistent Volume Terraform won't even attempt to create the PVC if creation of the PV has failed.

kubectl config set-context default-system \
  --cluster=chosen-cluster \
  --user=chosen-user

kubectl config use-context default-system

Kubernetes Provider for Standalone Cluster:

terraform import kubernetes_secret.example default/my-secret

resource "kubernetes_secret" "example" {
  metadata {
    name = "docker-cfg"
  }
provider "kubernetes" {
  load_config_file = "false"

  host = "http://52.186.65.23/"

  username = "gopal"
  password = "*******"
}

  data = {
    ".dockerconfigjson" = "${file("${path.module}/.docker/config.json")}"
  }

  type = "kubernetes.io/dockerconfigjson"
}

resource "kubernetes_ingress" "example_ingress" {
  metadata {
    name = "example-ingress"
  }

  spec {
    backend {
      service_name = "MyApp1"
      service_port = 8080
    }

    rule {
      http {
        path {
          backend {
            service_name = "MyApp1"
            service_port = 8080
          }

          path = "/app1/*"
        }

        }
    }    
  }
}
resource "kubernetes_pod" "example" {
  metadata {
    name = "terraform-example"
    labels = {
      app = "MyApp1"
    }
  }

  spec {
    container {
      image = "gopal/tomcat9"
      name  = "example"

      port {
        container_port = 8080
      }
    }
  }
}
resource "kubernetes_deployment" "example" {
  metadata {
    name = "terraform-example"
    labels = {
      test = "MyApp1"
    }
  }

  spec {
    replicas = 3

    selector {
      match_labels = {
        test = "MyApp1"
      }
    }

    template {
      metadata {
        labels = {
          test = "MyApp1"
        }
      }

      spec {
        container {
          image = "gopal/tomcat9"
          name  = "example"

          resources {
            limits {
              cpu    = "0.5"
              memory = "512Mi"
            }
            requests {
              cpu    = "250m"
              memory = "50Mi"
            }
          }          
        }
      }
    }
  }
}


-----------------------------------------------------


10.0.1.6 kmaster
10.0.1.5 knode

kubeadm init --apiserver-advertise-address=10.0.1.6 --pod-network-cidr=192.168.0.0/16

kubectl apply -f https://docs.projectcalico.org/v3.11/manifests/calico.yaml

kubectl get pods --all-namespaces

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 10.0.1.6:6443 --token nxvlsk.ykrc4xy246koaihf \
    --discovery-token-ca-cert-hash sha256:4f4d3159252fa1c2296191d9bae4d4a2a3265c50cf02d696a5d00c71719170e7
root@kmaster:

-------------------------------------------------------
Docker file for Tomcat:

FROM openjdk:11-jdk

#RUN mkdir /opt/tomcat/

ENV CATALINA_HOME /usr/local/tomcat
ENV PATH $CATALINA_HOME/bin:$PATH
RUN mkdir -p "$CATALINA_HOME"
WORKDIR $CATALINA_HOME


#WORKDIR /opt/tomcat

# let "Tomcat Native" live somewhere isolated
ENV TOMCAT_NATIVE_LIBDIR $CATALINA_HOME/native-jni-lib
ENV LD_LIBRARY_PATH ${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}$TOMCAT_NATIVE_LIBDIR

# see https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/KEYS
# see also "update.sh" (https://github.com/docker-library/tomcat/blob/master/update.sh)
ENV GPG_KEYS 05AB33110949707C93A279E3D3EFE6B686867BA6 07E48665A34DCAFAE522E5E6266191C37C037D42 47309207D818FFD8DCD3F83F1931D684307A10A5 541FBE7D8F78B25E055DDEE13C370389288584E7 61B832AC2F1C5A90F0F9B00A1C506407564C17A3 79F7026C690BAA50B92CD8B66A3AD3F4F22C4FED 9BA44C2621385CB966EBA586F72C284D731FABEE A27677289986DB50844682F8ACB77FC2E86E29AC A9C5DF4D22E99998D9875A5110C01C5A2F6059E7 DCFD35E0BF8CA7344752DE8B6FB21E8933C60243 F3A04C595DB5B6A5F1ECA43E3B7BBB100D811BBE F7DA48BB64BCB84ECBA7EE6935CD23C10D498E23

ENV TOMCAT_MAJOR 9
ENV TOMCAT_VERSION 9.0.34
ENV TOMCAT_SHA512 9cb32f8807c0e8d2457d52ac032bb496ae7921e1ea0a0c8e6082bf8da60bb57c317a3f2376589962123dd803fdd2816ff960339cb851d9859b2241165fbc278e

RUN set -eux; \
        \
        savedAptMark="$(apt-mark showmanual)"; \
        apt-get update; \
        apt-get install -y --no-install-recommends \
                gnupg dirmngr \
                wget ca-certificates \
        ; \
        \
        ddist() { \
                local f="$1"; shift; \
                local distFile="$1"; shift; \
                local mvnFile="${1:-}"; \
                local success=; \
                local distUrl=; \
                for distUrl in \
# https://issues.apache.org/jira/browse/INFRA-8753?focusedCommentId=14735394#comment-14735394
                        "https://www.apache.org/dyn/closer.cgi?action=download&filename=$distFile" \
# if the version is outdated (or we're grabbing the .asc file), we might have to pull from the dist/archive :/
                        "https://www-us.apache.org/dist/$distFile" \
                        "https://www.apache.org/dist/$distFile" \
                        "https://archive.apache.org/dist/$distFile" \
# if all else fails, let's try Maven (https://www.mail-archive.com/users@tomcat.apache.org/msg134940.html; https://mvnrepository.com/artifact/org.apache.tomcat/tomcat; https://repo1.maven.org/maven2/org/apache/tomcat/tomcat/)
                        ${mvnFile:+"https://repo1.maven.org/maven2/org/apache/tomcat/tomcat/$mvnFile"} \
                ; do \
                        if wget -O "$f" "$distUrl" && [ -s "$f" ]; then \
                                success=1; \
                                break; \
                        fi; \
                done; \
                [ -n "$success" ]; \
        }; \
        \
        ddist 'tomcat.tar.gz' "tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz" "$TOMCAT_VERSION/tomcat-$TOMCAT_VERSION.tar.gz"; \
        echo "$TOMCAT_SHA512 *tomcat.tar.gz" | sha512sum --strict --check -; \
        ddist 'tomcat.tar.gz.asc' "tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc" "$TOMCAT_VERSION/tomcat-$TOMCAT_VERSION.tar.gz.asc"; \
        export GNUPGHOME="$(mktemp -d)"; \
        for key in $GPG_KEYS; do \
                gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys "$key"; \
        done; \
        gpg --batch --verify tomcat.tar.gz.asc tomcat.tar.gz; \
        tar -xf tomcat.tar.gz --strip-components=1; \
        rm bin/*.bat; \
        rm tomcat.tar.gz*; \
        command -v gpgconf && gpgconf --kill all || :; \
        rm -rf "$GNUPGHOME"; \
        \
# https://tomcat.apache.org/tomcat-9.0-doc/security-howto.html#Default_web_applications
        mv webapps webapps.dist; \
        mkdir webapps; \
# we don't delete them completely because they're frankly a pain to get back for users who do want them, and they're generally tiny (~7MB)
        \
        nativeBuildDir="$(mktemp -d)"; \
        tar -xf bin/tomcat-native.tar.gz -C "$nativeBuildDir" --strip-components=1; \
        apt-get install -y --no-install-recommends \
                dpkg-dev \
                gcc \
                libapr1-dev \
                libssl-dev \
                make \
        ; \
        ( \
                export CATALINA_HOME="$PWD"; \
                cd "$nativeBuildDir/native"; \
                gnuArch="$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)"; \
                aprConfig="$(command -v apr-1-config)"; \
                ./configure \
                        --build="$gnuArch" \
                        --libdir="$TOMCAT_NATIVE_LIBDIR" \
                        --prefix="$CATALINA_HOME" \
                        --with-apr="$aprConfig" \
                        --with-java-home="$JAVA_HOME" \
                        --with-ssl=yes; \
                make -j "$(nproc)"; \
                make install; \
        ); \
        rm -rf "$nativeBuildDir"; \
        rm bin/tomcat-native.tar.gz; \
        \
# reset apt-mark's "manual" list so that "purge --auto-remove" will remove all build dependencies
        apt-mark auto '.*' > /dev/null; \
        [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark > /dev/null; \
        find "$TOMCAT_NATIVE_LIBDIR" -type f -executable -exec ldd '{}' ';' \
                | awk '/=>/ { print $(NF-1) }' \
                | sort -u \
                | xargs -r dpkg-query --search \
                | cut -d: -f1 \
                | sort -u \
                | xargs -r apt-mark manual \
        ; \
        apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
        rm -rf /var/lib/apt/lists/*; \
        \
# sh removes env vars it doesn't support (ones with periods)
# https://github.com/docker-library/tomcat/issues/77
        find ./bin/ -name '*.sh' -exec sed -ri 's|^#!/bin/sh$|#!/usr/bin/env bash|' '{}' +; \
        \
# fix permissions (especially for running as non-root)
# https://github.com/docker-library/tomcat/issues/35
        chmod -R +rX .; \
        chmod 777 logs temp work

# verify Tomcat Native is working properly
RUN set -e \
        && nativeLines="$(catalina.sh configtest 2>&1)" \
        && nativeLines="$(echo "$nativeLines" | grep 'Apache Tomcat Native')" \
        && nativeLines="$(echo "$nativeLines" | sort -u)" \
        && if ! echo "$nativeLines" | grep 'INFO: Loaded APR based Apache Tomcat Native library' >&2; then \
                echo >&2 "$nativeLines"; \
                exit 1; \
        fi

#RUN apt-get -y install java
RUN java -version

WORKDIR /usr/local/tomcat/webapps
RUN curl -O -L https://github.com/AKSarav/SampleWebApp/raw/master/dist/SampleWebApp.war

EXPOSE 8080

CMD ["catalina.sh", "run"]

-----------------------------------

replicaset-definition.yml:

apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: myapp-replicaset
  labels:
    app: myapp
    type: front-end
spec:
  template:
    metadata:
      name: myapp-pod
      labels:
        app: myapp
        type: front-end

    spec:
      containers:
        - name: testingwarfile
          image: gopal/tomcat9

  replicas: 3

  selector:
    matchLabels:
      app: myapp

